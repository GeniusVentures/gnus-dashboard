// Property test for protobuf serialization round-trip
const fs = require('fs');
const path = require('path');

describe('Protobuf Serialization Round-trip Property Tests', () => {
  // Feature: sdk-protobuf-upgrade, Property 7: Protobuf Serialization Round-trip
  
  test('all protobuf files should support round-trip serialization', () => {
    const protobufFiles = [
      'data/protobuf/crdt/bcast.ts',
      'data/protobuf/crdt/delta.ts',
      'data/protobuf/crdt/heads.ts',
      'data/protobuf/processing/SGProcessing.ts',
      'data/protobuf/SGTransaction.ts',
      'data/protobuf/SGBlocks.ts'
    ];
    
    protobufFiles.forEach(filePath => {
      const fullPath = path.join(__dirname, '../../', filePath);
      
      if (fs.existsSync(fullPath)) {
        const content = fs.readFileSync(fullPath, 'utf8');
        
        // Should have toBinary or similar serialization method
        expect(content).toMatch(/toBinary|internalBinaryWrite/);
        
        // Should have fromBinary or similar deserialization method
        expect(content).toMatch(/fromBinary|internalBinaryRead/);
        
        // Should have MessageType for round-trip support
        expect(content).toMatch(/MessageType/);
      }
    });
  });

  test('transaction parsing should support round-trip for all types', () => {
    const nodePath = path.join(__dirname, '../../functions/ipfs/node.ts');
    const content = fs.readFileSync(nodePath, 'utf8');
    
    // Should parse MintTx
    expect(content).toMatch(/MintTx\.fromBinary/);
    
    // Should parse ProcessingTx
    expect(content).toMatch(/ProcessingTx\.fromBinary/);
    
    // Should parse EscrowTx
    expect(content).toMatch(/EscrowTx\.fromBinary/);
    
    // All transaction types should be importable
    expect(content).toMatch(/MintTx.*ProcessingTx.*EscrowTx/s);
  });

  test('CRDT messages should support round-trip serialization', () => {
    const crdtFiles = [
      'data/protobuf/crdt/bcast.ts',
      'data/protobuf/crdt/delta.ts',
      'data/protobuf/crdt/heads.ts'
    ];
    
    crdtFiles.forEach(filePath => {
      const fullPath = path.join(__dirname, '../../', filePath);
      const content = fs.readFileSync(fullPath, 'utf8');
      
      // Should have proper interface definitions
      expect(content).toMatch(/export interface/);
      
      // Should have MessageType class for serialization
      expect(content).toMatch(/class.*MessageType/);
      
      // Should support binary operations
      expect(content).toMatch(/internalBinaryRead|internalBinaryWrite/);
    });
  });

  test('processing messages should support round-trip serialization', () => {
    const sgProcessingPath = path.join(__dirname, '../../data/protobuf/processing/SGProcessing.ts');
    const content = fs.readFileSync(sgProcessingPath, 'utf8');
    
    // Should have multiple message types
    expect(content).toMatch(/export interface Task/);
    expect(content).toMatch(/export interface SubTask/);
    expect(content).toMatch(/export interface TaskResult/);
    
    // Each should support serialization
    const messageTypes = content.match(/class.*MessageType/g) || [];
    expect(messageTypes.length).toBeGreaterThan(0);
  });

  test('protobuf runtime should provide consistent serialization', () => {
    const protobufFiles = [
      'data/protobuf/crdt/bcast.ts',
      'data/protobuf/processing/SGProcessing.ts'
    ];
    
    protobufFiles.forEach(filePath => {
      const fullPath = path.join(__dirname, '../../', filePath);
      const content = fs.readFileSync(fullPath, 'utf8');
      
      // Should use consistent runtime version
      expect(content).toMatch(/@generated by protobuf-ts 2\.11\./);
      
      // Should import from same runtime package
      expect(content).toMatch(/@protobuf-ts\/runtime/);
      
      // Should use WireType for encoding
      expect(content).toMatch(/WireType/);
    });
  });

  test('binary data should maintain integrity through round-trip', () => {
    const nodePath = path.join(__dirname, '../../functions/ipfs/node.ts');
    const content = fs.readFileSync(nodePath, 'utf8');
    
    // Should decode binary data properly
    expect(content).toMatch(/koffi\.decode.*uint8_t/);
    
    // Should handle Uint8Array data
    expect(content).toMatch(/Uint8Array/);
    
    // Should check data buffer existence
    expect(content).toMatch(/dataBuffer/);
  });

  test('message parsing should handle errors without data corruption', () => {
    const nodePath = path.join(__dirname, '../../functions/ipfs/node.ts');
    const content = fs.readFileSync(nodePath, 'utf8');
    
    // Should have try-catch for each message type
    expect(content).toMatch(/try[\s\S]*fromBinary[\s\S]*catch/);
    
    // Should continue to next type on parse failure
    expect(content).toMatch(/catch[\s\S]*console\.log[\s\S]*Cannot Decode/);
    
    // Should not corrupt data on failed parse
    expect(content).toMatch(/return/); // Should return after successful parse
  });
});