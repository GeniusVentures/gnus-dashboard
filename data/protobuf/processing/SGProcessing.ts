// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "SGProcessing.proto" (package "SGProcessing", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// import "google/protobuf/empty.proto";

/**
 * Work distribution
 * Task messages are published/received in data feed (lobby) channel
 *
 * @generated from protobuf message SGProcessing.Task
 */
export interface Task {
    /**
     * @generated from protobuf field: string ipfs_block_id = 1
     */
    ipfsBlockId: string; // source block data to be processed
    /**
     * @generated from protobuf field: bytes json_data = 2
     */
    jsonData: Uint8Array; // Job information json
    /**
     * uint32 block_len = 3; // and ipfs block's length in bytes
     * uint32 block_stride = 4; // Stride to use for access pattern
     * uint32 block_line_stride = 5; // Line stride in bytes to get to next block start
     *
     * @generated from protobuf field: float random_seed = 3
     */
    randomSeed: number; // used to randomly choose verifier block
    /**
     * @generated from protobuf field: string results_channel = 4
     */
    resultsChannel: string; // which channel to publish results to.
    /**
     * @generated from protobuf field: string escrow_path = 5
     */
    escrowPath: string; // the path of the escrow transaction
}
/**
 * @generated from protobuf message SGProcessing.TaskLock
 */
export interface TaskLock {
    /**
     * @generated from protobuf field: string task_id = 1
     */
    taskId: string;
    /**
     * @generated from protobuf field: uint64 lock_timestamp = 2
     */
    lockTimestamp: bigint;
    /**
     * @generated from protobuf field: uint64 lock_expiration_timestamp = 3
     */
    lockExpirationTimestamp: bigint;
}
/**
 * Subtask is pubished by host into ipfs_block_id channel
 *
 * @generated from protobuf message SGProcessing.SubTask
 */
export interface SubTask {
    /**
     * @generated from protobuf field: string ipfsblock = 1
     */
    ipfsblock: string; // source block data to be processed
    /**
     * @generated from protobuf field: string json_data = 2
     */
    jsonData: string; // json data of the specific inputs for this subtask
    /**
     * @generated from protobuf field: repeated SGProcessing.ProcessingChunk chunksToProcess = 3
     */
    chunksToProcess: ProcessingChunk[]; // array of chunks to process
    /**
     * @generated from protobuf field: uint32 datalen = 4
     */
    datalen: number; // length of ipfsBlock?
    /**
     * @generated from protobuf field: string subtaskid = 5
     */
    subtaskid: string; // unique subtask ID
}
/**
 * @generated from protobuf message SGProcessing.ProcessingChunk
 */
export interface ProcessingChunk {
    /**
     * @generated from protobuf field: string chunkid = 1
     */
    chunkid: string; // unique process chunk ID
    /**
     * uint32 offset = 2; // offset into data
     * uint32 subchunk_width = 3; // width of subchunk/subblock
     * uint32 subchunk_height = 4; // height of chunk/block
     * uint32 stride = 5; // stride to use for overall data chunk
     * uint32 line_stride = 6; // stride of one line of data
     *
     * @generated from protobuf field: uint32 n_subchunks = 2
     */
    nSubchunks: number; // number of chunks to process  
}
/**
 * @generated from protobuf message SGProcessing.ProcessingQueueItem
 */
export interface ProcessingQueueItem {
    /**
     * @generated from protobuf field: uint64 lock_timestamp = 1
     */
    lockTimestamp: bigint;
    /**
     * @generated from protobuf field: string lock_node_id = 2
     */
    lockNodeId: string;
    /**
     * @generated from protobuf field: uint64 lock_expiration_timestamp = 3
     */
    lockExpirationTimestamp: bigint;
}
/**
 * @generated from protobuf message SGProcessing.OwnershipRequest
 */
export interface OwnershipRequest {
    /**
     * @generated from protobuf field: string node_id = 1
     */
    nodeId: string;
    /**
     * @generated from protobuf field: uint64 request_timestamp = 2
     */
    requestTimestamp: bigint; // Timestamp when request was created
}
/**
 * @generated from protobuf message SGProcessing.ProcessingQueue
 */
export interface ProcessingQueue {
    /**
     * @generated from protobuf field: repeated SGProcessing.ProcessingQueueItem items = 1
     */
    items: ProcessingQueueItem[];
    /**
     * @generated from protobuf field: uint64 last_update_timestamp = 2
     */
    lastUpdateTimestamp: bigint;
    /**
     * @generated from protobuf field: uint64 processing_timeout_length = 3
     */
    processingTimeoutLength: bigint;
    /**
     * @generated from protobuf field: string owner_node_id = 4
     */
    ownerNodeId: string;
    /**
     * @generated from protobuf field: repeated SGProcessing.OwnershipRequest ownership_requests = 5
     */
    ownershipRequests: OwnershipRequest[];
    /**
     * @generated from protobuf field: repeated string processed_subtask_ids = 6
     */
    processedSubtaskIds: string[];
}
/**
 * @generated from protobuf message SGProcessing.SubTaskCollection
 */
export interface SubTaskCollection {
    /**
     * @generated from protobuf field: repeated SGProcessing.SubTask items = 1
     */
    items: SubTask[];
}
/**
 * @generated from protobuf message SGProcessing.SubTaskQueue
 */
export interface SubTaskQueue {
    /**
     * @generated from protobuf field: SGProcessing.ProcessingQueue processing_queue = 1
     */
    processingQueue?: ProcessingQueue;
    /**
     * @generated from protobuf field: SGProcessing.SubTaskCollection subtasks = 2
     */
    subtasks?: SubTaskCollection;
}
/**
 * @generated from protobuf message SGProcessing.SubTaskQueueRequest
 */
export interface SubTaskQueueRequest {
    /**
     * @generated from protobuf field: string node_id = 1
     */
    nodeId: string;
    /**
     * @generated from protobuf field: uint64 request_timestamp = 2
     */
    requestTimestamp: bigint;
}
/**
 * SubTask results are published to result_channel
 *
 * @generated from protobuf message SGProcessing.SubTaskResult
 */
export interface SubTaskResult {
    /**
     * @generated from protobuf field: bytes result_hash = 1
     */
    resultHash: Uint8Array; // hash of results
    /**
     * @generated from protobuf field: repeated bytes chunk_hashes = 2
     */
    chunkHashes: Uint8Array[]; // the hashes for each chunk
    /**
     * @generated from protobuf field: string ipfs_results_data_id = 3
     */
    ipfsResultsDataId: string; // UUID of the results data on ipfs
    /**
     * @generated from protobuf field: string subtaskid = 4
     */
    subtaskid: string; // linked subtask id
    /**
     * @generated from protobuf field: string node_address = 5
     */
    nodeAddress: string; // The processor node ID/address
    /**
     * @generated from protobuf field: bytes token_id = 6
     */
    tokenId: Uint8Array;
}
/**
 * @generated from protobuf message SGProcessing.SubTaskState
 */
export interface SubTaskState {
    /**
     * @generated from protobuf field: SGProcessing.SubTaskState.Type state = 1
     */
    state: SubTaskState_Type;
    /**
     * @generated from protobuf field: uint64 timestamp = 2
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf enum SGProcessing.SubTaskState.Type
 */
export enum SubTaskState_Type {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: ENQUEUED = 1;
     */
    ENQUEUED = 1,
    /**
     * @generated from protobuf enum value: PROCESSING = 2;
     */
    PROCESSING = 2,
    /**
     * @generated from protobuf enum value: PROCESSED = 3;
     */
    PROCESSED = 3,
    /**
     * @generated from protobuf enum value: COMPLETE = 4;
     */
    COMPLETE = 4
}
/**
 * @generated from protobuf message SGProcessing.TaskResult
 */
export interface TaskResult {
    /**
     * @generated from protobuf field: repeated SGProcessing.SubTaskResult subtask_results = 1
     */
    subtaskResults: SubTaskResult[];
}
/**
 * Processing service handling
 * Request for available processing channels
 *
 * @generated from protobuf message SGProcessing.ProcessingChannelRequest
 */
export interface ProcessingChannelRequest {
    /**
     * @generated from protobuf field: string environment = 1
     */
    environment: string; // environment description required for a task processing
}
/**
 * @generated from protobuf message SGProcessing.ProcessingChannelResponse
 */
export interface ProcessingChannelResponse {
    /**
     * @generated from protobuf field: string channel_id = 1
     */
    channelId: string; // Processing channel Id
}
/**
 * @generated from protobuf message SGProcessing.NodeCreationIntent
 */
export interface NodeCreationIntent {
    /**
     * @generated from protobuf field: string peer_address = 1
     */
    peerAddress: string;
    /**
     * @generated from protobuf field: string subtask_queue_id = 2
     */
    subtaskQueueId: string;
}
/**
 * @generated from protobuf message SGProcessing.GridChannelMessage
 */
export interface GridChannelMessage {
    /**
     * @generated from protobuf oneof: data
     */
    data: {
        oneofKind: "processingChannelRequest";
        /**
         * @generated from protobuf field: SGProcessing.ProcessingChannelRequest processing_channel_request = 1
         */
        processingChannelRequest: ProcessingChannelRequest;
    } | {
        oneofKind: "processingChannelResponse";
        /**
         * @generated from protobuf field: SGProcessing.ProcessingChannelResponse processing_channel_response = 2
         */
        processingChannelResponse: ProcessingChannelResponse;
    } | {
        oneofKind: "nodeCreationIntent";
        /**
         * @generated from protobuf field: SGProcessing.NodeCreationIntent node_creation_intent = 3
         */
        nodeCreationIntent: NodeCreationIntent;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message SGProcessing.ProcessingNode
 */
export interface ProcessingNode {
    /**
     * @generated from protobuf field: string node_id = 1
     */
    nodeId: string;
    /**
     * @generated from protobuf field: uint64 timestamp = 2
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message SGProcessing.ProcessingChannelMessage
 */
export interface ProcessingChannelMessage {
    /**
     * @generated from protobuf oneof: data
     */
    data: {
        oneofKind: "subtaskQueue";
        /**
         * @generated from protobuf field: SGProcessing.SubTaskQueue subtask_queue = 1
         */
        subtaskQueue: SubTaskQueue;
    } | {
        oneofKind: "subtaskQueueRequest";
        /**
         * @generated from protobuf field: SGProcessing.SubTaskQueueRequest subtask_queue_request = 2
         */
        subtaskQueueRequest: SubTaskQueueRequest;
    } | {
        oneofKind: undefined;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class Task$Type extends MessageType<Task> {
    constructor() {
        super("SGProcessing.Task", [
            { no: 1, name: "ipfs_block_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "json_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "random_seed", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "results_channel", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "escrow_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Task>): Task {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ipfsBlockId = "";
        message.jsonData = new Uint8Array(0);
        message.randomSeed = 0;
        message.resultsChannel = "";
        message.escrowPath = "";
        if (value !== undefined)
            reflectionMergePartial<Task>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Task): Task {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ipfs_block_id */ 1:
                    message.ipfsBlockId = reader.string();
                    break;
                case /* bytes json_data */ 2:
                    message.jsonData = reader.bytes();
                    break;
                case /* float random_seed */ 3:
                    message.randomSeed = reader.float();
                    break;
                case /* string results_channel */ 4:
                    message.resultsChannel = reader.string();
                    break;
                case /* string escrow_path */ 5:
                    message.escrowPath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Task, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ipfs_block_id = 1; */
        if (message.ipfsBlockId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ipfsBlockId);
        /* bytes json_data = 2; */
        if (message.jsonData.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.jsonData);
        /* float random_seed = 3; */
        if (message.randomSeed !== 0)
            writer.tag(3, WireType.Bit32).float(message.randomSeed);
        /* string results_channel = 4; */
        if (message.resultsChannel !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.resultsChannel);
        /* string escrow_path = 5; */
        if (message.escrowPath !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.escrowPath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SGProcessing.Task
 */
export const Task = new Task$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskLock$Type extends MessageType<TaskLock> {
    constructor() {
        super("SGProcessing.TaskLock", [
            { no: 1, name: "task_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "lock_timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "lock_expiration_timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TaskLock>): TaskLock {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = "";
        message.lockTimestamp = 0n;
        message.lockExpirationTimestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<TaskLock>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskLock): TaskLock {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string task_id */ 1:
                    message.taskId = reader.string();
                    break;
                case /* uint64 lock_timestamp */ 2:
                    message.lockTimestamp = reader.uint64().toBigInt();
                    break;
                case /* uint64 lock_expiration_timestamp */ 3:
                    message.lockExpirationTimestamp = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskLock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string task_id = 1; */
        if (message.taskId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.taskId);
        /* uint64 lock_timestamp = 2; */
        if (message.lockTimestamp !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.lockTimestamp);
        /* uint64 lock_expiration_timestamp = 3; */
        if (message.lockExpirationTimestamp !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.lockExpirationTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SGProcessing.TaskLock
 */
export const TaskLock = new TaskLock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubTask$Type extends MessageType<SubTask> {
    constructor() {
        super("SGProcessing.SubTask", [
            { no: 1, name: "ipfsblock", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "json_data", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "chunksToProcess", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ProcessingChunk },
            { no: 4, name: "datalen", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "subtaskid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubTask>): SubTask {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ipfsblock = "";
        message.jsonData = "";
        message.chunksToProcess = [];
        message.datalen = 0;
        message.subtaskid = "";
        if (value !== undefined)
            reflectionMergePartial<SubTask>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubTask): SubTask {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ipfsblock */ 1:
                    message.ipfsblock = reader.string();
                    break;
                case /* string json_data */ 2:
                    message.jsonData = reader.string();
                    break;
                case /* repeated SGProcessing.ProcessingChunk chunksToProcess */ 3:
                    message.chunksToProcess.push(ProcessingChunk.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 datalen */ 4:
                    message.datalen = reader.uint32();
                    break;
                case /* string subtaskid */ 5:
                    message.subtaskid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubTask, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ipfsblock = 1; */
        if (message.ipfsblock !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ipfsblock);
        /* string json_data = 2; */
        if (message.jsonData !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.jsonData);
        /* repeated SGProcessing.ProcessingChunk chunksToProcess = 3; */
        for (let i = 0; i < message.chunksToProcess.length; i++)
            ProcessingChunk.internalBinaryWrite(message.chunksToProcess[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint32 datalen = 4; */
        if (message.datalen !== 0)
            writer.tag(4, WireType.Varint).uint32(message.datalen);
        /* string subtaskid = 5; */
        if (message.subtaskid !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.subtaskid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SGProcessing.SubTask
 */
export const SubTask = new SubTask$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessingChunk$Type extends MessageType<ProcessingChunk> {
    constructor() {
        super("SGProcessing.ProcessingChunk", [
            { no: 1, name: "chunkid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "n_subchunks", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ProcessingChunk>): ProcessingChunk {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chunkid = "";
        message.nSubchunks = 0;
        if (value !== undefined)
            reflectionMergePartial<ProcessingChunk>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessingChunk): ProcessingChunk {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string chunkid */ 1:
                    message.chunkid = reader.string();
                    break;
                case /* uint32 n_subchunks */ 2:
                    message.nSubchunks = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessingChunk, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string chunkid = 1; */
        if (message.chunkid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.chunkid);
        /* uint32 n_subchunks = 2; */
        if (message.nSubchunks !== 0)
            writer.tag(2, WireType.Varint).uint32(message.nSubchunks);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SGProcessing.ProcessingChunk
 */
export const ProcessingChunk = new ProcessingChunk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessingQueueItem$Type extends MessageType<ProcessingQueueItem> {
    constructor() {
        super("SGProcessing.ProcessingQueueItem", [
            { no: 1, name: "lock_timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "lock_node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "lock_expiration_timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ProcessingQueueItem>): ProcessingQueueItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.lockTimestamp = 0n;
        message.lockNodeId = "";
        message.lockExpirationTimestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<ProcessingQueueItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessingQueueItem): ProcessingQueueItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 lock_timestamp */ 1:
                    message.lockTimestamp = reader.uint64().toBigInt();
                    break;
                case /* string lock_node_id */ 2:
                    message.lockNodeId = reader.string();
                    break;
                case /* uint64 lock_expiration_timestamp */ 3:
                    message.lockExpirationTimestamp = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessingQueueItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 lock_timestamp = 1; */
        if (message.lockTimestamp !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.lockTimestamp);
        /* string lock_node_id = 2; */
        if (message.lockNodeId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.lockNodeId);
        /* uint64 lock_expiration_timestamp = 3; */
        if (message.lockExpirationTimestamp !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.lockExpirationTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SGProcessing.ProcessingQueueItem
 */
export const ProcessingQueueItem = new ProcessingQueueItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OwnershipRequest$Type extends MessageType<OwnershipRequest> {
    constructor() {
        super("SGProcessing.OwnershipRequest", [
            { no: 1, name: "node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "request_timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<OwnershipRequest>): OwnershipRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nodeId = "";
        message.requestTimestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<OwnershipRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OwnershipRequest): OwnershipRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string node_id */ 1:
                    message.nodeId = reader.string();
                    break;
                case /* uint64 request_timestamp */ 2:
                    message.requestTimestamp = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OwnershipRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string node_id = 1; */
        if (message.nodeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.nodeId);
        /* uint64 request_timestamp = 2; */
        if (message.requestTimestamp !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.requestTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SGProcessing.OwnershipRequest
 */
export const OwnershipRequest = new OwnershipRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessingQueue$Type extends MessageType<ProcessingQueue> {
    constructor() {
        super("SGProcessing.ProcessingQueue", [
            { no: 1, name: "items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ProcessingQueueItem },
            { no: 2, name: "last_update_timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "processing_timeout_length", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "owner_node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "ownership_requests", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OwnershipRequest },
            { no: 6, name: "processed_subtask_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ProcessingQueue>): ProcessingQueue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        message.lastUpdateTimestamp = 0n;
        message.processingTimeoutLength = 0n;
        message.ownerNodeId = "";
        message.ownershipRequests = [];
        message.processedSubtaskIds = [];
        if (value !== undefined)
            reflectionMergePartial<ProcessingQueue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessingQueue): ProcessingQueue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated SGProcessing.ProcessingQueueItem items */ 1:
                    message.items.push(ProcessingQueueItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 last_update_timestamp */ 2:
                    message.lastUpdateTimestamp = reader.uint64().toBigInt();
                    break;
                case /* uint64 processing_timeout_length */ 3:
                    message.processingTimeoutLength = reader.uint64().toBigInt();
                    break;
                case /* string owner_node_id */ 4:
                    message.ownerNodeId = reader.string();
                    break;
                case /* repeated SGProcessing.OwnershipRequest ownership_requests */ 5:
                    message.ownershipRequests.push(OwnershipRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string processed_subtask_ids */ 6:
                    message.processedSubtaskIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessingQueue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated SGProcessing.ProcessingQueueItem items = 1; */
        for (let i = 0; i < message.items.length; i++)
            ProcessingQueueItem.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 last_update_timestamp = 2; */
        if (message.lastUpdateTimestamp !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.lastUpdateTimestamp);
        /* uint64 processing_timeout_length = 3; */
        if (message.processingTimeoutLength !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.processingTimeoutLength);
        /* string owner_node_id = 4; */
        if (message.ownerNodeId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.ownerNodeId);
        /* repeated SGProcessing.OwnershipRequest ownership_requests = 5; */
        for (let i = 0; i < message.ownershipRequests.length; i++)
            OwnershipRequest.internalBinaryWrite(message.ownershipRequests[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated string processed_subtask_ids = 6; */
        for (let i = 0; i < message.processedSubtaskIds.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.processedSubtaskIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SGProcessing.ProcessingQueue
 */
export const ProcessingQueue = new ProcessingQueue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubTaskCollection$Type extends MessageType<SubTaskCollection> {
    constructor() {
        super("SGProcessing.SubTaskCollection", [
            { no: 1, name: "items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SubTask }
        ]);
    }
    create(value?: PartialMessage<SubTaskCollection>): SubTaskCollection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<SubTaskCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubTaskCollection): SubTaskCollection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated SGProcessing.SubTask items */ 1:
                    message.items.push(SubTask.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubTaskCollection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated SGProcessing.SubTask items = 1; */
        for (let i = 0; i < message.items.length; i++)
            SubTask.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SGProcessing.SubTaskCollection
 */
export const SubTaskCollection = new SubTaskCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubTaskQueue$Type extends MessageType<SubTaskQueue> {
    constructor() {
        super("SGProcessing.SubTaskQueue", [
            { no: 1, name: "processing_queue", kind: "message", T: () => ProcessingQueue },
            { no: 2, name: "subtasks", kind: "message", T: () => SubTaskCollection }
        ]);
    }
    create(value?: PartialMessage<SubTaskQueue>): SubTaskQueue {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubTaskQueue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubTaskQueue): SubTaskQueue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* SGProcessing.ProcessingQueue processing_queue */ 1:
                    message.processingQueue = ProcessingQueue.internalBinaryRead(reader, reader.uint32(), options, message.processingQueue);
                    break;
                case /* SGProcessing.SubTaskCollection subtasks */ 2:
                    message.subtasks = SubTaskCollection.internalBinaryRead(reader, reader.uint32(), options, message.subtasks);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubTaskQueue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* SGProcessing.ProcessingQueue processing_queue = 1; */
        if (message.processingQueue)
            ProcessingQueue.internalBinaryWrite(message.processingQueue, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* SGProcessing.SubTaskCollection subtasks = 2; */
        if (message.subtasks)
            SubTaskCollection.internalBinaryWrite(message.subtasks, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SGProcessing.SubTaskQueue
 */
export const SubTaskQueue = new SubTaskQueue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubTaskQueueRequest$Type extends MessageType<SubTaskQueueRequest> {
    constructor() {
        super("SGProcessing.SubTaskQueueRequest", [
            { no: 1, name: "node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "request_timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SubTaskQueueRequest>): SubTaskQueueRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nodeId = "";
        message.requestTimestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubTaskQueueRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubTaskQueueRequest): SubTaskQueueRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string node_id */ 1:
                    message.nodeId = reader.string();
                    break;
                case /* uint64 request_timestamp */ 2:
                    message.requestTimestamp = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubTaskQueueRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string node_id = 1; */
        if (message.nodeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.nodeId);
        /* uint64 request_timestamp = 2; */
        if (message.requestTimestamp !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.requestTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SGProcessing.SubTaskQueueRequest
 */
export const SubTaskQueueRequest = new SubTaskQueueRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubTaskResult$Type extends MessageType<SubTaskResult> {
    constructor() {
        super("SGProcessing.SubTaskResult", [
            { no: 1, name: "result_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "chunk_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "ipfs_results_data_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subtaskid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "node_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "token_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SubTaskResult>): SubTaskResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resultHash = new Uint8Array(0);
        message.chunkHashes = [];
        message.ipfsResultsDataId = "";
        message.subtaskid = "";
        message.nodeAddress = "";
        message.tokenId = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SubTaskResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubTaskResult): SubTaskResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes result_hash */ 1:
                    message.resultHash = reader.bytes();
                    break;
                case /* repeated bytes chunk_hashes */ 2:
                    message.chunkHashes.push(reader.bytes());
                    break;
                case /* string ipfs_results_data_id */ 3:
                    message.ipfsResultsDataId = reader.string();
                    break;
                case /* string subtaskid */ 4:
                    message.subtaskid = reader.string();
                    break;
                case /* string node_address */ 5:
                    message.nodeAddress = reader.string();
                    break;
                case /* bytes token_id */ 6:
                    message.tokenId = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubTaskResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes result_hash = 1; */
        if (message.resultHash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.resultHash);
        /* repeated bytes chunk_hashes = 2; */
        for (let i = 0; i < message.chunkHashes.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.chunkHashes[i]);
        /* string ipfs_results_data_id = 3; */
        if (message.ipfsResultsDataId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ipfsResultsDataId);
        /* string subtaskid = 4; */
        if (message.subtaskid !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subtaskid);
        /* string node_address = 5; */
        if (message.nodeAddress !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.nodeAddress);
        /* bytes token_id = 6; */
        if (message.tokenId.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.tokenId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SGProcessing.SubTaskResult
 */
export const SubTaskResult = new SubTaskResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubTaskState$Type extends MessageType<SubTaskState> {
    constructor() {
        super("SGProcessing.SubTaskState", [
            { no: 1, name: "state", kind: "enum", T: () => ["SGProcessing.SubTaskState.Type", SubTaskState_Type] },
            { no: 2, name: "timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SubTaskState>): SubTaskState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = 0;
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubTaskState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubTaskState): SubTaskState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* SGProcessing.SubTaskState.Type state */ 1:
                    message.state = reader.int32();
                    break;
                case /* uint64 timestamp */ 2:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubTaskState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* SGProcessing.SubTaskState.Type state = 1; */
        if (message.state !== 0)
            writer.tag(1, WireType.Varint).int32(message.state);
        /* uint64 timestamp = 2; */
        if (message.timestamp !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SGProcessing.SubTaskState
 */
export const SubTaskState = new SubTaskState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskResult$Type extends MessageType<TaskResult> {
    constructor() {
        super("SGProcessing.TaskResult", [
            { no: 1, name: "subtask_results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SubTaskResult }
        ]);
    }
    create(value?: PartialMessage<TaskResult>): TaskResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subtaskResults = [];
        if (value !== undefined)
            reflectionMergePartial<TaskResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskResult): TaskResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated SGProcessing.SubTaskResult subtask_results */ 1:
                    message.subtaskResults.push(SubTaskResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated SGProcessing.SubTaskResult subtask_results = 1; */
        for (let i = 0; i < message.subtaskResults.length; i++)
            SubTaskResult.internalBinaryWrite(message.subtaskResults[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SGProcessing.TaskResult
 */
export const TaskResult = new TaskResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessingChannelRequest$Type extends MessageType<ProcessingChannelRequest> {
    constructor() {
        super("SGProcessing.ProcessingChannelRequest", [
            { no: 1, name: "environment", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ProcessingChannelRequest>): ProcessingChannelRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.environment = "";
        if (value !== undefined)
            reflectionMergePartial<ProcessingChannelRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessingChannelRequest): ProcessingChannelRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string environment */ 1:
                    message.environment = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessingChannelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string environment = 1; */
        if (message.environment !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.environment);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SGProcessing.ProcessingChannelRequest
 */
export const ProcessingChannelRequest = new ProcessingChannelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessingChannelResponse$Type extends MessageType<ProcessingChannelResponse> {
    constructor() {
        super("SGProcessing.ProcessingChannelResponse", [
            { no: 1, name: "channel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ProcessingChannelResponse>): ProcessingChannelResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.channelId = "";
        if (value !== undefined)
            reflectionMergePartial<ProcessingChannelResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessingChannelResponse): ProcessingChannelResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string channel_id */ 1:
                    message.channelId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessingChannelResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string channel_id = 1; */
        if (message.channelId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.channelId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SGProcessing.ProcessingChannelResponse
 */
export const ProcessingChannelResponse = new ProcessingChannelResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NodeCreationIntent$Type extends MessageType<NodeCreationIntent> {
    constructor() {
        super("SGProcessing.NodeCreationIntent", [
            { no: 1, name: "peer_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subtask_queue_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<NodeCreationIntent>): NodeCreationIntent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.peerAddress = "";
        message.subtaskQueueId = "";
        if (value !== undefined)
            reflectionMergePartial<NodeCreationIntent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NodeCreationIntent): NodeCreationIntent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string peer_address */ 1:
                    message.peerAddress = reader.string();
                    break;
                case /* string subtask_queue_id */ 2:
                    message.subtaskQueueId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NodeCreationIntent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string peer_address = 1; */
        if (message.peerAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.peerAddress);
        /* string subtask_queue_id = 2; */
        if (message.subtaskQueueId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subtaskQueueId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SGProcessing.NodeCreationIntent
 */
export const NodeCreationIntent = new NodeCreationIntent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GridChannelMessage$Type extends MessageType<GridChannelMessage> {
    constructor() {
        super("SGProcessing.GridChannelMessage", [
            { no: 1, name: "processing_channel_request", kind: "message", oneof: "data", T: () => ProcessingChannelRequest },
            { no: 2, name: "processing_channel_response", kind: "message", oneof: "data", T: () => ProcessingChannelResponse },
            { no: 3, name: "node_creation_intent", kind: "message", oneof: "data", T: () => NodeCreationIntent }
        ]);
    }
    create(value?: PartialMessage<GridChannelMessage>): GridChannelMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<GridChannelMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GridChannelMessage): GridChannelMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* SGProcessing.ProcessingChannelRequest processing_channel_request */ 1:
                    message.data = {
                        oneofKind: "processingChannelRequest",
                        processingChannelRequest: ProcessingChannelRequest.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).processingChannelRequest)
                    };
                    break;
                case /* SGProcessing.ProcessingChannelResponse processing_channel_response */ 2:
                    message.data = {
                        oneofKind: "processingChannelResponse",
                        processingChannelResponse: ProcessingChannelResponse.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).processingChannelResponse)
                    };
                    break;
                case /* SGProcessing.NodeCreationIntent node_creation_intent */ 3:
                    message.data = {
                        oneofKind: "nodeCreationIntent",
                        nodeCreationIntent: NodeCreationIntent.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).nodeCreationIntent)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GridChannelMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* SGProcessing.ProcessingChannelRequest processing_channel_request = 1; */
        if (message.data.oneofKind === "processingChannelRequest")
            ProcessingChannelRequest.internalBinaryWrite((message.data as any).processingChannelRequest, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* SGProcessing.ProcessingChannelResponse processing_channel_response = 2; */
        if (message.data.oneofKind === "processingChannelResponse")
            ProcessingChannelResponse.internalBinaryWrite((message.data as any).processingChannelResponse, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* SGProcessing.NodeCreationIntent node_creation_intent = 3; */
        if (message.data.oneofKind === "nodeCreationIntent")
            NodeCreationIntent.internalBinaryWrite((message.data as any).nodeCreationIntent, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SGProcessing.GridChannelMessage
 */
export const GridChannelMessage = new GridChannelMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessingNode$Type extends MessageType<ProcessingNode> {
    constructor() {
        super("SGProcessing.ProcessingNode", [
            { no: 1, name: "node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ProcessingNode>): ProcessingNode {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nodeId = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<ProcessingNode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessingNode): ProcessingNode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string node_id */ 1:
                    message.nodeId = reader.string();
                    break;
                case /* uint64 timestamp */ 2:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessingNode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string node_id = 1; */
        if (message.nodeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.nodeId);
        /* uint64 timestamp = 2; */
        if (message.timestamp !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SGProcessing.ProcessingNode
 */
export const ProcessingNode = new ProcessingNode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessingChannelMessage$Type extends MessageType<ProcessingChannelMessage> {
    constructor() {
        super("SGProcessing.ProcessingChannelMessage", [
            { no: 1, name: "subtask_queue", kind: "message", oneof: "data", T: () => SubTaskQueue },
            { no: 2, name: "subtask_queue_request", kind: "message", oneof: "data", T: () => SubTaskQueueRequest }
        ]);
    }
    create(value?: PartialMessage<ProcessingChannelMessage>): ProcessingChannelMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ProcessingChannelMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessingChannelMessage): ProcessingChannelMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* SGProcessing.SubTaskQueue subtask_queue */ 1:
                    message.data = {
                        oneofKind: "subtaskQueue",
                        subtaskQueue: SubTaskQueue.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).subtaskQueue)
                    };
                    break;
                case /* SGProcessing.SubTaskQueueRequest subtask_queue_request */ 2:
                    message.data = {
                        oneofKind: "subtaskQueueRequest",
                        subtaskQueueRequest: SubTaskQueueRequest.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).subtaskQueueRequest)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessingChannelMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* SGProcessing.SubTaskQueue subtask_queue = 1; */
        if (message.data.oneofKind === "subtaskQueue")
            SubTaskQueue.internalBinaryWrite((message.data as any).subtaskQueue, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* SGProcessing.SubTaskQueueRequest subtask_queue_request = 2; */
        if (message.data.oneofKind === "subtaskQueueRequest")
            SubTaskQueueRequest.internalBinaryWrite((message.data as any).subtaskQueueRequest, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SGProcessing.ProcessingChannelMessage
 */
export const ProcessingChannelMessage = new ProcessingChannelMessage$Type();
